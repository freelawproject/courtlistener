# Generated by Django 3.1.7 on 2021-05-28 19:34

import django.db.models.deletion
from django.db import migrations, models

import cl.lib.fields
import cl.lib.model_helpers
import cl.lib.storage


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('recap', '0001_initial'),
        ('people_db', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Claim',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_created', models.DateTimeField(auto_now_add=True, db_index=True, help_text='The moment when the item was created.')),
                ('date_modified', models.DateTimeField(auto_now=True, db_index=True, help_text='The last moment when the item was modified. A value in year 1750 indicates the value is unknown')),
                ('date_claim_modified', models.DateTimeField(blank=True, help_text='Date the claim was last modified to our knowledge.', null=True)),
                ('date_original_entered', models.DateTimeField(blank=True, help_text='Date the claim was originally entered.', null=True)),
                ('date_original_filed', models.DateTimeField(blank=True, help_text='Date the claim was originally filed.', null=True)),
                ('date_last_amendment_entered', models.DateTimeField(blank=True, help_text='Date the last amendment was entered.', null=True)),
                ('date_last_amendment_filed', models.DateTimeField(blank=True, help_text='Date the last amendment was filed.', null=True)),
                ('claim_number', models.CharField(blank=True, db_index=True, help_text='The number of the claim.', max_length=10)),
                ('creditor_details', models.TextField(blank=True, help_text='The details of the creditor from the claims register; typically their address.')),
                ('creditor_id', models.CharField(blank=True, help_text='The ID of the creditor from the claims register; typically a seven digit number', max_length=50)),
                ('status', models.CharField(blank=True, help_text='The status of the claim.', max_length=1000)),
                ('entered_by', models.CharField(blank=True, help_text='The person that entered the claim.', max_length=1000)),
                ('filed_by', models.CharField(blank=True, help_text='The person that filed the claim.', max_length=1000)),
                ('amount_claimed', models.CharField(blank=True, help_text='The amount claimed, usually in dollars.', max_length=100)),
                ('unsecured_claimed', models.CharField(blank=True, help_text='The unsecured claimed, usually in dollars.', max_length=100)),
                ('secured_claimed', models.CharField(blank=True, help_text='The secured claimed, usually in dollars.', max_length=100)),
                ('priority_claimed', models.CharField(blank=True, help_text='The priority claimed, usually in dollars.', max_length=100)),
                ('description', models.TextField(blank=True, help_text='The description of the claim that appears on the claim register.')),
                ('remarks', models.TextField(blank=True, help_text='The remarks of the claim that appear on the claim register.')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='Court',
            fields=[
                ('id', models.CharField(help_text='a unique ID for each court as used in URLs', max_length=15, primary_key=True, serialize=False)),
                ('pacer_court_id', models.PositiveSmallIntegerField(blank=True, help_text='The numeric ID for the court in PACER. This can be found by looking at the first three digits of any doc1 URL in PACER.', null=True)),
                ('pacer_has_rss_feed', models.BooleanField(blank=True, help_text="Whether the court has a PACER RSS feed. If null, this doesn't apply to the given court.", null=True)),
                ('pacer_rss_entry_types', models.TextField(blank=True, help_text="The types of entries provided by the court's RSS feed.")),
                ('date_last_pacer_contact', models.DateTimeField(blank=True, help_text='The last time the PACER website for the court was successfully contacted', null=True)),
                ('fjc_court_id', models.CharField(blank=True, help_text='The ID used by FJC in the Integrated Database', max_length=3)),
                ('date_modified', models.DateTimeField(auto_now=True, db_index=True, help_text='The last moment when the item was modified')),
                ('in_use', models.BooleanField(default=False, help_text='Whether this jurisdiction is in use in CourtListener -- increasingly True')),
                ('has_opinion_scraper', models.BooleanField(default=False, help_text='Whether the jurisdiction has a scraper that obtains opinions automatically.')),
                ('has_oral_argument_scraper', models.BooleanField(default=False, help_text='Whether the jurisdiction has a scraper that obtains oral arguments automatically.')),
                ('position', models.FloatField(db_index=True, help_text='A dewey-decimal-style numeral indicating a hierarchical ordering of jurisdictions', unique=True)),
                ('citation_string', models.CharField(blank=True, help_text='the citation abbreviation for the court as dictated by Blue Book', max_length=100)),
                ('short_name', models.CharField(help_text='a short name of the court', max_length=100)),
                ('full_name', models.CharField(help_text='the full name of the court', max_length=200)),
                ('url', models.URLField(blank=True, help_text='the homepage for each court or the closest thing thereto', max_length=500)),
                ('start_date', models.DateField(blank=True, help_text='the date the court was established, if known', null=True)),
                ('end_date', models.DateField(blank=True, help_text='the date the court was abolished, if known', null=True)),
                ('jurisdiction', models.CharField(choices=[('F', 'Federal Appellate'), ('FD', 'Federal District'), ('FB', 'Federal Bankruptcy'), ('FBP', 'Federal Bankruptcy Panel'), ('FS', 'Federal Special'), ('S', 'State Supreme'), ('SA', 'State Appellate'), ('ST', 'State Trial'), ('SS', 'State Special'), ('SAG', 'State Attorney General'), ('C', 'Committee'), ('I', 'International'), ('T', 'Testing')], help_text='the jurisdiction of the court, one of: F (Federal Appellate), FD (Federal District), FB (Federal Bankruptcy), FBP (Federal Bankruptcy Panel), FS (Federal Special), S (State Supreme), SA (State Appellate), ST (State Trial), SS (State Special), SAG (State Attorney General), C (Committee), I (International), T (Testing)', max_length=3)),
                ('notes', models.TextField(blank=True, help_text='any notes about coverage or anything else (currently very raw)')),
            ],
            options={
                'ordering': ['position'],
            },
        ),
        migrations.CreateModel(
            name='Docket',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_created', models.DateTimeField(auto_now_add=True, db_index=True, help_text='The moment when the item was created.')),
                ('date_modified', models.DateTimeField(auto_now=True, db_index=True, help_text='The last moment when the item was modified. A value in year 1750 indicates the value is unknown')),
                ('source', models.SmallIntegerField(choices=[(0, 'Default'), (1, 'RECAP'), (2, 'Scraper'), (3, 'RECAP and Scraper'), (4, 'Columbia'), (6, 'Columbia and Scraper'), (5, 'Columbia and RECAP'), (7, 'Columbia, RECAP, and Scraper'), (8, 'Integrated Database'), (9, 'RECAP and IDB'), (10, 'Scraper and IDB'), (11, 'RECAP, Scraper, and IDB'), (12, 'Columbia and IDB'), (13, 'Columbia, RECAP, and IDB'), (14, 'Columbia, Scraper, and IDB'), (15, 'Columbia, RECAP, Scraper, and IDB'), (16, 'Harvard'), (17, 'Scraper and Harvard'), (32, 'Direct court input'), (64, '2020 anonymous database'), (66, '2020 anonymous database and Scraper'), (80, '2020 anonymous database and Harvard'), (82, '2020 anonymous database, Scraper, and Harvard')], help_text='contains the source of the Docket.')),
                ('appeal_from_str', models.TextField(blank=True, help_text='In appellate cases, this is the lower court or administrative body where this case was originally heard. This field is frequently blank due to it not being populated historically. This field may have values when the appeal_from field does not. That can happen if we are unable to normalize the value in this field.')),
                ('assigned_to_str', models.TextField(blank=True, help_text='The judge that the case was assigned to, as a string.')),
                ('referred_to_str', models.TextField(blank=True, help_text='The judge that the case was referred to, as a string.')),
                ('panel_str', models.TextField(blank=True, help_text="The initials of the judges on the panel that heard this case. This field is similar to the 'judges' field on the cluster, but contains initials instead of full judge names, and applies to the case on the whole instead of only to a specific decision.")),
                ('date_last_index', models.DateTimeField(blank=True, help_text='The last moment that the item was indexed in Solr.', null=True)),
                ('date_cert_granted', models.DateField(blank=True, db_index=True, help_text='date cert was granted for this case, if applicable', null=True)),
                ('date_cert_denied', models.DateField(blank=True, db_index=True, help_text='the date cert was denied for this case, if applicable', null=True)),
                ('date_argued', models.DateField(blank=True, db_index=True, help_text='the date the case was argued', null=True)),
                ('date_reargued', models.DateField(blank=True, db_index=True, help_text='the date the case was reargued', null=True)),
                ('date_reargument_denied', models.DateField(blank=True, db_index=True, help_text='the date the reargument was denied', null=True)),
                ('date_filed', models.DateField(blank=True, help_text='The date the case was filed.', null=True)),
                ('date_terminated', models.DateField(blank=True, help_text='The date the case was terminated.', null=True)),
                ('date_last_filing', models.DateField(blank=True, help_text="The date the case was last updated in the docket, as shown in PACER's Docket History report or iquery page.", null=True)),
                ('case_name_short', models.TextField(blank=True, help_text="The abridged name of the case, often a single word, e.g. 'Marsh'")),
                ('case_name', models.TextField(blank=True, help_text='The standard name of the case')),
                ('case_name_full', models.TextField(blank=True, help_text='The full name of the case')),
                ('slug', models.SlugField(blank=True, db_index=False, help_text='URL that the document should map to (the slug)', max_length=75)),
                ('docket_number', models.TextField(blank=True, db_index=True, help_text='The docket numbers of a case, can be consolidated and quite long. In some instances they are too long to be indexed by postgres and we store the full docket in the correction field on the Opinion Cluster.', null=True)),
                ('docket_number_core', models.CharField(blank=True, db_index=True, help_text='For federal district court dockets, this is the most distilled docket number available. In this field, the docket number is stripped down to only the year and serial digits, eliminating the office at the beginning, letters in the middle, and the judge at the end. Thus, a docket number like 2:07-cv-34911-MJL becomes simply 0734911. This is the format that is provided by the IDB and is useful for de-duplication types of activities which otherwise get messy. We use a char field here to preserve leading zeros.', max_length=20)),
                ('pacer_case_id', cl.lib.fields.CharNullField(blank=True, db_index=True, help_text='The cased ID provided by PACER.', max_length=100, null=True)),
                ('cause', models.CharField(blank=True, help_text='The cause for the case.', max_length=2000)),
                ('nature_of_suit', models.CharField(blank=True, help_text='The nature of suit code from PACER.', max_length=1000)),
                ('jury_demand', models.CharField(blank=True, help_text='The compensation demand.', max_length=500)),
                ('jurisdiction_type', models.CharField(blank=True, help_text="Stands for jurisdiction in RECAP XML docket. For example, 'Diversity', 'U.S. Government Defendant'.", max_length=100)),
                ('appellate_fee_status', models.TextField(blank=True, help_text='The status of the fee in the appellate court. Can be used as a hint as to whether the government is the appellant (in which case the fee is waived).')),
                ('appellate_case_type_information', models.TextField(blank=True, help_text="Information about a case from the appellate docket in PACER. For example, 'civil, private, bankruptcy'.")),
                ('mdl_status', models.CharField(blank=True, help_text='The MDL status of a case before the Judicial Panel for Multidistrict Litigation', max_length=100)),
                ('filepath_local', models.FileField(blank=True, help_text="Path to RECAP's Docket XML page as provided by the original RECAP architecture. These fields are for backup purposes only. Note that the field name is historical, from before when we used S3. To find the location in S3, concatenate https://storage.courtlistener.com/ and the value of this field.", max_length=1000, storage=cl.lib.storage.IncrementingAWSMediaStorage(), upload_to=cl.lib.model_helpers.make_recap_path)),
                ('filepath_ia', models.CharField(blank=True, help_text='Path to the Docket XML page in The Internet Archive', max_length=1000)),
                ('filepath_ia_json', models.CharField(blank=True, help_text='Path to the docket JSON page in the Internet Archive', max_length=1000)),
                ('ia_upload_failure_count', models.SmallIntegerField(blank=True, help_text='Number of times the upload to the Internet Archive failed.', null=True)),
                ('ia_needs_upload', models.BooleanField(blank=True, help_text="Does this item need to be uploaded to the Internet Archive? I.e., has it changed? This field is important because it keeps track of the status of all the related objects to the docket. For example, if a related docket entry changes, we need to upload the item to IA, but we can't easily check that.", null=True)),
                ('ia_date_first_change', models.DateTimeField(blank=True, db_index=True, help_text='The moment when this item first changed and was marked as needing an upload. Used for determining when to upload an item.', null=True)),
                ('view_count', models.IntegerField(default=0, help_text='The number of times the docket has been seen.')),
                ('date_blocked', models.DateField(blank=True, db_index=True, help_text='The date that this opinion was blocked from indexing by search engines', null=True)),
                ('blocked', models.BooleanField(default=False, help_text='Whether a document should be blocked from indexing by search engines')),
                ('appeal_from', models.ForeignKey(blank=True, help_text='In appellate cases, this is the lower court or administrative body where this case was originally heard. This field is frequently blank due to it not being populated historically or due to our inability to normalize the value in appeal_from_str.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='+', to='search.court')),
                ('assigned_to', models.ForeignKey(blank=True, help_text='The judge the case was assigned to.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='assigning', to='people_db.person')),
                ('court', models.ForeignKey(help_text='The court where the docket was filed', on_delete=django.db.models.deletion.CASCADE, related_name='dockets', to='search.court')),
                ('idb_data', models.OneToOneField(blank=True, help_text='Data from the FJC Integrated Database associated with this case.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='docket', to='recap.fjcintegrateddatabase')),
            ],
        ),
        migrations.CreateModel(
            name='DocketEntry',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_created', models.DateTimeField(auto_now_add=True, db_index=True, help_text='The moment when the item was created.')),
                ('date_modified', models.DateTimeField(auto_now=True, db_index=True, help_text='The last moment when the item was modified. A value in year 1750 indicates the value is unknown')),
                ('date_filed', models.DateField(blank=True, help_text='The created date of the Docket Entry.', null=True)),
                ('entry_number', models.BigIntegerField(blank=True, help_text='# on the PACER docket page. For appellate cases, this may be the internal PACER ID for the document, when an entry ID is otherwise unavailable.', null=True)),
                ('recap_sequence_number', models.CharField(blank=True, help_text='A field used for ordering the docket entries on a docket. You might wonder, "Why not use the docket entry numbers?" That\'s a reasonable question, and prior to late 2018, this was the method we used. However, dockets often have "unnumbered" docket entries, and so knowing where to put those was only possible if you had another sequencing field, since they lacked an entry number. This field is populated by a combination of the date for the entry and a sequence number indicating the order that the unnumbered entries occur.', max_length=50)),
                ('pacer_sequence_number', models.IntegerField(blank=True, help_text='The de_seqno value pulled out of dockets, RSS feeds, and sundry other pages in PACER. The place to find this is currently in the onclick attribute of the links in PACER. Because we do not have this value for all items in the DB, we do not use this value for anything. Still, we collect it for good measure.', null=True)),
                ('description', models.TextField(blank=True, help_text='The text content of the docket entry that appears in the PACER docket page.')),
                ('docket', models.ForeignKey(help_text='Foreign key as a relation to the corresponding Docket object. Specifies which docket the docket entry belongs to.', on_delete=django.db.models.deletion.CASCADE, related_name='docket_entries', to='search.docket')),
            ],
            options={
                'verbose_name_plural': 'Docket Entries',
                'ordering': ('recap_sequence_number', 'entry_number'),
                'permissions': (('has_recap_api_access', 'Can work with RECAP API'),),
            },
        ),
        migrations.CreateModel(
            name='Opinion',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_created', models.DateTimeField(auto_now_add=True, db_index=True, help_text='The moment when the item was created.')),
                ('date_modified', models.DateTimeField(auto_now=True, db_index=True, help_text='The last moment when the item was modified. A value in year 1750 indicates the value is unknown')),
                ('author_str', models.TextField(blank=True, help_text='The primary author of this opinion, as a simple text string. This field is used when normalized judges cannot be placed into the author field.')),
                ('per_curiam', models.BooleanField(default=False, help_text='Is this opinion per curiam, without a single author?')),
                ('joined_by_str', models.TextField(blank=True, help_text='Other judges that joined the primary author in this opinion str')),
                ('type', models.CharField(choices=[('010combined', 'Combined Opinion'), ('015unamimous', 'Unanimous Opinion'), ('020lead', 'Lead Opinion'), ('025plurality', 'Plurality Opinion'), ('030concurrence', 'Concurrence Opinion'), ('035concurrenceinpart', 'In Part Opinion'), ('040dissent', 'Dissent'), ('050addendum', 'Addendum'), ('060remittitur', 'Remittitur'), ('070rehearing', 'Rehearing'), ('080onthemerits', 'On the Merits'), ('090onmotiontostrike', 'On Motion to Strike Cost Bill')], max_length=20)),
                ('sha1', models.CharField(blank=True, db_index=True, help_text='unique ID for the document, as generated via SHA1 of the binary file or text data', max_length=40)),
                ('page_count', models.IntegerField(blank=True, help_text='The number of pages in the document, if known', null=True)),
                ('download_url', models.URLField(blank=True, db_index=True, help_text='The URL where the item was originally scraped. Note that these URLs may often be dead due to the court or the bulk provider changing their website. We keep the original link here given that it often contains valuable metadata.', max_length=500, null=True)),
                ('local_path', models.FileField(blank=True, db_index=True, help_text='The location in AWS S3 where the original opinion file is stored. Note that the field name is historical, from before when we used S3. To find the location in S3, concatenate https://storage.courtlistener.com/ and the value of this field.', storage=cl.lib.storage.IncrementingAWSMediaStorage(), upload_to=cl.lib.model_helpers.make_upload_path)),
                ('plain_text', models.TextField(blank=True, help_text='Plain text of the document after extraction using pdftotext, wpd2txt, etc.')),
                ('html', models.TextField(blank=True, help_text='HTML of the document, if available in the original')),
                ('html_lawbox', models.TextField(blank=True, help_text='HTML of Lawbox documents')),
                ('html_columbia', models.TextField(blank=True, help_text='HTML of Columbia archive')),
                ('html_anon_2020', models.TextField(blank=True, help_text='HTML of 2020 anonymous archive')),
                ('xml_harvard', models.TextField(blank=True, help_text='XML of Harvard CaseLaw Access Project opinion')),
                ('html_with_citations', models.TextField(blank=True, help_text='HTML of the document with citation links and other post-processed markup added')),
                ('extracted_by_ocr', models.BooleanField(db_index=True, default=False, help_text='Whether OCR was used to get this document content')),
                ('author', models.ForeignKey(blank=True, help_text='The primary author of this opinion as a normalized field', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='opinions_written', to='people_db.person')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='Tag',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_created', models.DateTimeField(auto_now_add=True, db_index=True, help_text='The moment when the item was created.')),
                ('date_modified', models.DateTimeField(auto_now=True, db_index=True, help_text='The last moment when the item was modified. A value in year 1750 indicates the value is unknown')),
                ('name', models.CharField(db_index=True, help_text='The name of the tag.', max_length=50, unique=True)),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='RECAPDocument',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_created', models.DateTimeField(auto_now_add=True, db_index=True, help_text='The moment when the item was created.')),
                ('date_modified', models.DateTimeField(auto_now=True, db_index=True, help_text='The last moment when the item was modified. A value in year 1750 indicates the value is unknown')),
                ('sha1', models.CharField(blank=True, help_text='The ID used for a document in RECAP', max_length=40)),
                ('page_count', models.IntegerField(blank=True, help_text='The number of pages in the document, if known', null=True)),
                ('file_size', models.IntegerField(blank=True, help_text='The size of the file in bytes, if known', null=True)),
                ('filepath_local', models.FileField(blank=True, help_text='The path is AWS S3 where the file is saved. Note that the field name is historical, from before when we used S3. To find the location in S3, concatenate https://storage.courtlistener.com/ and the value of this field.', max_length=1000, storage=cl.lib.storage.IncrementingAWSMediaStorage(), upload_to=cl.lib.model_helpers.make_pdf_path)),
                ('filepath_ia', models.CharField(blank=True, help_text='The URL of the file in IA', max_length=1000)),
                ('ia_upload_failure_count', models.SmallIntegerField(blank=True, help_text='Number of times the upload to the Internet Archive failed.', null=True)),
                ('thumbnail', models.FileField(blank=True, help_text='The path to a thumbnail in S3 of the first page of the document.', null=True, storage=cl.lib.storage.IncrementingAWSMediaStorage(), upload_to=cl.lib.model_helpers.make_pdf_thumb_path)),
                ('thumbnail_status', models.SmallIntegerField(choices=[(0, 'Thumbnail needed'), (1, 'Thumbnail completed successfully'), (2, 'Unable to generate thumbnail')], default=0, help_text='The status of the thumbnail generation')),
                ('plain_text', models.TextField(blank=True, help_text='Plain text of the document after extraction using pdftotext, wpd2txt, etc.')),
                ('ocr_status', models.SmallIntegerField(blank=True, choices=[(1, 'OCR Complete'), (2, 'OCR Not Necessary'), (3, 'OCR Failed'), (4, 'OCR Needed')], help_text='The status of OCR processing on this item.', null=True)),
                ('date_upload', models.DateTimeField(blank=True, help_text='upload_date in RECAP. The date the file was uploaded to RECAP. This information is provided by RECAP.', null=True)),
                ('document_number', models.CharField(blank=True, db_index=True, help_text='If the file is a document, the number is the document_number in RECAP docket.', max_length=32)),
                ('attachment_number', models.SmallIntegerField(blank=True, help_text='If the file is an attachment, the number is the attachment number in RECAP docket.', null=True)),
                ('pacer_doc_id', models.CharField(blank=True, help_text='The ID of the document in PACER. This information is provided by RECAP.', max_length=32)),
                ('is_available', models.BooleanField(blank=True, default=False, help_text='True if the item is available in RECAP', null=True)),
                ('is_free_on_pacer', models.BooleanField(db_index=True, help_text='Is this item freely available as an opinion on PACER?', null=True)),
                ('is_sealed', models.BooleanField(help_text='Is this item sealed or otherwise unavailable on PACER?', null=True)),
                ('document_type', models.IntegerField(choices=[(1, 'PACER Document'), (2, 'Attachment')], help_text='Whether this is a regular document or an attachment.')),
                ('description', models.TextField(blank=True, help_text='The short description of the docket entry that appears on the attachments page.')),
                ('docket_entry', models.ForeignKey(help_text='Foreign Key to the DocketEntry object to which it belongs. Multiple documents can belong to a DocketEntry. (Attachments and Documents together)', on_delete=django.db.models.deletion.CASCADE, related_name='recap_documents', to='search.docketentry')),
                ('tags', models.ManyToManyField(blank=True, help_text='The tags associated with the document.', related_name='recap_documents', to='search.Tag')),
            ],
            options={
                'ordering': ('document_type', 'document_number', 'attachment_number'),
                'permissions': (('has_recap_api_access', 'Can work with RECAP API'),),
            },
        ),
        migrations.CreateModel(
            name='OriginatingCourtInformation',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_created', models.DateTimeField(auto_now_add=True, db_index=True, help_text='The moment when the item was created.')),
                ('date_modified', models.DateTimeField(auto_now=True, db_index=True, help_text='The last moment when the item was modified. A value in year 1750 indicates the value is unknown')),
                ('docket_number', models.TextField(blank=True, help_text='The docket number in the lower court.')),
                ('assigned_to_str', models.TextField(blank=True, help_text='The judge that the case was assigned to, as a string.')),
                ('ordering_judge_str', models.TextField(blank=True, help_text='The judge that issued the final order in the case, as a string.')),
                ('court_reporter', models.TextField(blank=True, help_text='The court reporter responsible for the case.')),
                ('date_disposed', models.DateField(blank=True, help_text='The date the case was disposed at the lower court.', null=True)),
                ('date_filed', models.DateField(blank=True, help_text='The date the case was filed in the lower court.', null=True)),
                ('date_judgment', models.DateField(blank=True, help_text='The date of the order or judgment in the lower court.', null=True)),
                ('date_judgment_eod', models.DateField(blank=True, help_text='The date the judgment was Entered On the Docket at the lower court.', null=True)),
                ('date_filed_noa', models.DateField(blank=True, help_text='The date the notice of appeal was filed for the case.', null=True)),
                ('date_received_coa', models.DateField(blank=True, help_text='The date the case was received at the court of appeals.', null=True)),
                ('assigned_to', models.ForeignKey(blank=True, help_text='The judge the case was assigned to.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='original_court_info', to='people_db.person')),
                ('ordering_judge', models.ForeignKey(blank=True, help_text='The judge that issued the final order in the case.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='+', to='people_db.person')),
            ],
            options={
                'verbose_name_plural': 'Originating Court Information',
            },
        ),
        migrations.CreateModel(
            name='OpinionsCited',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('depth', models.IntegerField(db_index=True, default=1, help_text='The number of times the cited opinion was cited in the citing opinion')),
                ('cited_opinion', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='citing_opinions', to='search.opinion')),
                ('citing_opinion', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='cited_opinions', to='search.opinion')),
            ],
            options={
                'verbose_name_plural': 'Opinions cited',
            },
        ),
        migrations.CreateModel(
            name='OpinionCluster',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_created', models.DateTimeField(auto_now_add=True, db_index=True, help_text='The moment when the item was created.')),
                ('date_modified', models.DateTimeField(auto_now=True, db_index=True, help_text='The last moment when the item was modified. A value in year 1750 indicates the value is unknown')),
                ('judges', models.TextField(blank=True, help_text='The judges that participated in the opinion as a simple text string. This field is used when normalized judges cannot be placed into the panel field.')),
                ('date_filed', models.DateField(db_index=True, help_text='The date the cluster of opinions was filed by the court')),
                ('date_filed_is_approximate', models.BooleanField(default=False, help_text='For a variety of opinions getting the correct date filed isvery difficult. For these, we have used heuristics to approximate the date.')),
                ('slug', models.SlugField(db_index=False, help_text='URL that the document should map to (the slug)', max_length=75, null=True)),
                ('case_name_short', models.TextField(blank=True, help_text="The abridged name of the case, often a single word, e.g. 'Marsh'")),
                ('case_name', models.TextField(blank=True, help_text='The shortened name of the case')),
                ('case_name_full', models.TextField(blank=True, help_text='The full name of the case')),
                ('scdb_id', models.CharField(blank=True, db_index=True, help_text='The ID of the item in the Supreme Court Database', max_length=10)),
                ('scdb_decision_direction', models.IntegerField(blank=True, choices=[(1, 'Conservative'), (2, 'Liberal'), (3, 'Unspecifiable')], help_text='the ideological "direction" of a decision in the Supreme Court database. More details at: http://scdb.wustl.edu/documentation.php?var=decisionDirection', null=True)),
                ('scdb_votes_majority', models.IntegerField(blank=True, help_text='the number of justices voting in the majority in a Supreme Court decision. More details at: http://scdb.wustl.edu/documentation.php?var=majVotes', null=True)),
                ('scdb_votes_minority', models.IntegerField(blank=True, help_text='the number of justices voting in the minority in a Supreme Court decision. More details at: http://scdb.wustl.edu/documentation.php?var=minVotes', null=True)),
                ('source', models.CharField(blank=True, choices=[('C', 'court website'), ('R', 'public.resource.org'), ('CR', 'court website merged with resource.org'), ('L', 'lawbox'), ('LC', 'lawbox merged with court'), ('LR', 'lawbox merged with resource.org'), ('LCR', 'lawbox merged with court and resource.org'), ('M', 'manual input'), ('A', 'internet archive'), ('H', 'brad heath archive'), ('Z', 'columbia archive'), ('ZC', 'columbia merged with court'), ('ZLC', 'columbia merged with lawbox and court'), ('ZLR', 'columbia merged with lawbox and resource.org'), ('ZLCR', 'columbia merged with lawbox, court, and resource.org'), ('ZR', 'columbia merged with resource.org'), ('ZCR', 'columbia merged with court and resource.org'), ('ZL', 'columbia merged with lawbox'), ('U', 'Harvard, Library Innovation Lab Case Law Access Project'), ('CU', 'court website merged with Harvard'), ('D', 'direct court input')], help_text='the source of the cluster, one of: C (court website), R (public.resource.org), CR (court website merged with resource.org), L (lawbox), LC (lawbox merged with court), LR (lawbox merged with resource.org), LCR (lawbox merged with court and resource.org), M (manual input), A (internet archive), H (brad heath archive), Z (columbia archive), ZC (columbia merged with court), ZLC (columbia merged with lawbox and court), ZLR (columbia merged with lawbox and resource.org), ZLCR (columbia merged with lawbox, court, and resource.org), ZR (columbia merged with resource.org), ZCR (columbia merged with court and resource.org), ZL (columbia merged with lawbox), U (Harvard, Library Innovation Lab Case Law Access Project), CU (court website merged with Harvard), D (direct court input)', max_length=10)),
                ('procedural_history', models.TextField(blank=True, help_text='The history of the case as it jumped from court to court')),
                ('attorneys', models.TextField(blank=True, help_text='The attorneys that argued the case, as free text')),
                ('nature_of_suit', models.TextField(blank=True, help_text='The nature of the suit. For the moment can be codes or laws or whatever')),
                ('posture', models.TextField(blank=True, help_text='The procedural posture of the case.')),
                ('syllabus', models.TextField(blank=True, help_text='A summary of the issues presented in the case and the outcome.')),
                ('headnotes', models.TextField(blank=True, help_text='Headnotes are summary descriptions of the legal issues discussed by the court in the particular case. They appear at the beginning of each case just after the summary and disposition. They are short paragraphs with a heading in bold face type. From Wikipedia - A headnote is a brief summary of a particular point of law that is added to the text of a courtdecision to aid readers in locating discussion of a legalissue in an opinion. As the term implies, headnotes appearat the beginning of the published opinion. Frequently, headnotes are value-added components appended to decisions by the publisher who compiles the decisions of a court for resale. As handed down by the court, a decision or written opinion does not contain headnotes. These are added later by an editor not connected to the court, but who instead works for a legal publishing house.')),
                ('summary', models.TextField(blank=True, help_text='A summary of what happened in the case. Appears at the beginning of the case just after the title of the case and court information.')),
                ('disposition', models.TextField(blank=True, help_text='Description of the procedural outcome of the case, e.g. Reversed, dismissed etc. Generally a short paragraph that appears just after the summary or synopsis')),
                ('history', models.TextField(blank=True, help_text='History of the case (similar to the summary, but focused on past events related to this case). Appears at the beginning of the case just after the title of the case and court information')),
                ('other_dates', models.TextField(blank=True, help_text='Other date(s) as specified in the text (case header). This may include follow-up dates.')),
                ('cross_reference', models.TextField(blank=True, help_text='Cross-reference citation (often to a past or future similar case). It does NOT identify this case.')),
                ('correction', models.TextField(blank=True, help_text="Publisher's correction to the case text. Example: Replace last paragraph on page 476 with this text: blah blah blah. This is basically an unstructured text that can be used to manually correct case content according to publisher's instructions. No footnotes is expected within it.")),
                ('citation_count', models.IntegerField(db_index=True, default=0, help_text='The number of times this document is cited by other opinion')),
                ('precedential_status', models.CharField(blank=True, choices=[('Published', 'Precedential'), ('Unpublished', 'Non-Precedential'), ('Errata', 'Errata'), ('Separate', 'Separate Opinion'), ('In-chambers', 'In-chambers'), ('Relating-to', 'Relating-to orders'), ('Unknown', 'Unknown Status')], db_index=True, help_text='The precedential status of document, one of: Published, Unpublished, Errata, Separate, In-chambers, Relating-to, Unknown', max_length=50)),
                ('date_blocked', models.DateField(blank=True, db_index=True, help_text='The date that this opinion was blocked from indexing by search engines', null=True)),
                ('blocked', models.BooleanField(db_index=True, default=False, help_text='Whether a document should be blocked from indexing by search engines')),
                ('filepath_json_harvard', models.FileField(blank=True, db_index=True, help_text='Path to local storage of JSON collected from Harvard Case Law project containing available metadata, opinion and opinion cluster.', max_length=1000, upload_to='')),
                ('docket', models.ForeignKey(help_text='The docket that the opinion cluster is a part of', on_delete=django.db.models.deletion.CASCADE, related_name='clusters', to='search.docket')),
                ('non_participating_judges', models.ManyToManyField(blank=True, help_text='The judges that heard the case, but did not participate in the opinion', related_name='opinion_clusters_non_participating_judges', to='people_db.Person')),
                ('panel', models.ManyToManyField(blank=True, help_text='The judges that participated in the opinion', related_name='opinion_clusters_participating_judges', to='people_db.Person')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.AddField(
            model_name='opinion',
            name='cluster',
            field=models.ForeignKey(help_text='The cluster that the opinion is a part of', on_delete=django.db.models.deletion.CASCADE, related_name='sub_opinions', to='search.opinioncluster'),
        ),
        migrations.AddField(
            model_name='opinion',
            name='joined_by',
            field=models.ManyToManyField(blank=True, help_text='Other judges that joined the primary author in this opinion', related_name='opinions_joined', to='people_db.Person'),
        ),
        migrations.AddField(
            model_name='opinion',
            name='opinions_cited',
            field=models.ManyToManyField(blank=True, help_text='Opinions cited by this opinion', related_name='opinions_citing', through='search.OpinionsCited', to='search.Opinion'),
        ),
        migrations.AddField(
            model_name='docketentry',
            name='tags',
            field=models.ManyToManyField(blank=True, help_text='The tags associated with the docket entry.', related_name='docket_entries', to='search.Tag'),
        ),
        migrations.AddField(
            model_name='docket',
            name='originating_court_information',
            field=models.OneToOneField(blank=True, help_text='Lower court information for appellate dockets', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='docket', to='search.originatingcourtinformation'),
        ),
        migrations.AddField(
            model_name='docket',
            name='panel',
            field=models.ManyToManyField(blank=True, help_text='The empaneled judges for the case. Currently an unused field but planned to be used in conjunction with the panel_str field.', related_name='empanelled_dockets', to='people_db.Person'),
        ),
        migrations.AddField(
            model_name='docket',
            name='parties',
            field=models.ManyToManyField(blank=True, help_text='The parties involved in the docket', related_name='dockets', through='people_db.PartyType', to='people_db.Party'),
        ),
        migrations.AddField(
            model_name='docket',
            name='referred_to',
            field=models.ForeignKey(blank=True, help_text="The judge to whom the 'assigned_to' judge is delegated.", null=True, on_delete=django.db.models.deletion.CASCADE, related_name='referring', to='people_db.person'),
        ),
        migrations.AddField(
            model_name='docket',
            name='tags',
            field=models.ManyToManyField(blank=True, help_text='The tags associated with the docket.', related_name='dockets', to='search.Tag'),
        ),
        migrations.CreateModel(
            name='ClaimHistory',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_created', models.DateTimeField(auto_now_add=True, db_index=True, help_text='The moment when the item was created.')),
                ('date_modified', models.DateTimeField(auto_now=True, db_index=True, help_text='The last moment when the item was modified. A value in year 1750 indicates the value is unknown')),
                ('sha1', models.CharField(blank=True, help_text='The ID used for a document in RECAP', max_length=40)),
                ('page_count', models.IntegerField(blank=True, help_text='The number of pages in the document, if known', null=True)),
                ('file_size', models.IntegerField(blank=True, help_text='The size of the file in bytes, if known', null=True)),
                ('filepath_local', models.FileField(blank=True, help_text='The path is AWS S3 where the file is saved. Note that the field name is historical, from before when we used S3. To find the location in S3, concatenate https://storage.courtlistener.com/ and the value of this field.', max_length=1000, storage=cl.lib.storage.IncrementingAWSMediaStorage(), upload_to=cl.lib.model_helpers.make_pdf_path)),
                ('filepath_ia', models.CharField(blank=True, help_text='The URL of the file in IA', max_length=1000)),
                ('ia_upload_failure_count', models.SmallIntegerField(blank=True, help_text='Number of times the upload to the Internet Archive failed.', null=True)),
                ('thumbnail', models.FileField(blank=True, help_text='The path to a thumbnail in S3 of the first page of the document.', null=True, storage=cl.lib.storage.IncrementingAWSMediaStorage(), upload_to=cl.lib.model_helpers.make_pdf_thumb_path)),
                ('thumbnail_status', models.SmallIntegerField(choices=[(0, 'Thumbnail needed'), (1, 'Thumbnail completed successfully'), (2, 'Unable to generate thumbnail')], default=0, help_text='The status of the thumbnail generation')),
                ('plain_text', models.TextField(blank=True, help_text='Plain text of the document after extraction using pdftotext, wpd2txt, etc.')),
                ('ocr_status', models.SmallIntegerField(blank=True, choices=[(1, 'OCR Complete'), (2, 'OCR Not Necessary'), (3, 'OCR Failed'), (4, 'OCR Needed')], help_text='The status of OCR processing on this item.', null=True)),
                ('date_upload', models.DateTimeField(blank=True, help_text='upload_date in RECAP. The date the file was uploaded to RECAP. This information is provided by RECAP.', null=True)),
                ('document_number', models.CharField(blank=True, db_index=True, help_text='If the file is a document, the number is the document_number in RECAP docket.', max_length=32)),
                ('attachment_number', models.SmallIntegerField(blank=True, help_text='If the file is an attachment, the number is the attachment number in RECAP docket.', null=True)),
                ('pacer_doc_id', models.CharField(blank=True, help_text='The ID of the document in PACER. This information is provided by RECAP.', max_length=32)),
                ('is_available', models.BooleanField(blank=True, default=False, help_text='True if the item is available in RECAP', null=True)),
                ('is_free_on_pacer', models.BooleanField(db_index=True, help_text='Is this item freely available as an opinion on PACER?', null=True)),
                ('is_sealed', models.BooleanField(help_text='Is this item sealed or otherwise unavailable on PACER?', null=True)),
                ('date_filed', models.DateField(blank=True, help_text='The created date of the claim.', null=True)),
                ('claim_document_type', models.IntegerField(choices=[(1, 'A docket entry referenced from the claim register.'), (2, 'A document only referenced from the claim register')], help_text='The type of document that is used in the history row for the claim. One of: 1 (A docket entry referenced from the claim register.), 2 (A document only referenced from the claim register)')),
                ('description', models.TextField(blank=True, help_text='The text content of the docket entry that appears in the docket or claims registry page.')),
                ('claim_doc_id', models.CharField(blank=True, help_text='The ID of a claims registry document.', max_length=32)),
                ('pacer_dm_id', models.IntegerField(blank=True, help_text='The dm_id value pulled out of links and possibly other pages in PACER. Collected but not currently used.', null=True)),
                ('pacer_case_id', models.CharField(blank=True, help_text="The cased ID provided by PACER. Noted in this case on a per-document-level, since we've learned that some documents from other cases can appear in curious places.", max_length=100)),
                ('claim', models.ForeignKey(help_text='The claim that the history row is associated with.', on_delete=django.db.models.deletion.CASCADE, related_name='claim_history_entries', to='search.claim')),
            ],
            options={
                'verbose_name_plural': 'Claim History Entries',
            },
        ),
        migrations.AddField(
            model_name='claim',
            name='docket',
            field=models.ForeignKey(help_text='The docket that the claim is associated with.', on_delete=django.db.models.deletion.CASCADE, related_name='claims', to='search.docket'),
        ),
        migrations.AddField(
            model_name='claim',
            name='tags',
            field=models.ManyToManyField(blank=True, help_text='The tags associated with the document.', related_name='claims', to='search.Tag'),
        ),
        migrations.CreateModel(
            name='Citation',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('volume', models.SmallIntegerField(help_text='The volume of the reporter')),
                ('reporter', models.TextField(db_index=True, help_text='The abbreviation for the reporter')),
                ('page', models.TextField(help_text="The 'page' of the citation in the reporter. Unfortunately, this is not an integer, but is a string-type because several jurisdictions do funny things with the so-called 'page'. For example, we have seen Roman numerals in Nebraska, 13301-M in Connecticut, and 144M in Montana.")),
                ('type', models.SmallIntegerField(choices=[(1, 'A federal reporter citation (e.g. 5 F. 55)'), (2, 'A citation in a state-based reporter (e.g. Alabama Reports)'), (3, 'A citation in a regional reporter (e.g. Atlantic Reporter)'), (4, "A citation in a specialty reporter (e.g. Lawyers' Edition)"), (5, 'A citation in an early SCOTUS reporter (e.g. 5 Black. 55)'), (6, 'A citation in the Lexis system (e.g. 5 LEXIS 55)'), (7, 'A citation in the WestLaw system (e.g. 5 WL 55)'), (8, 'A vendor neutral citation (e.g. 2013 FL 1)')], help_text='The type of citation that this is.')),
                ('cluster', models.ForeignKey(help_text='The cluster that the citation applies to', on_delete=django.db.models.deletion.CASCADE, related_name='citations', to='search.opinioncluster')),
            ],
        ),
        migrations.CreateModel(
            name='BankruptcyInformation',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_created', models.DateTimeField(auto_now_add=True, db_index=True, help_text='The moment when the item was created.')),
                ('date_modified', models.DateTimeField(auto_now=True, db_index=True, help_text='The last moment when the item was modified. A value in year 1750 indicates the value is unknown')),
                ('date_converted', models.DateTimeField(blank=True, help_text='The date when the bankruptcy was converted from one chapter to another.', null=True)),
                ('date_last_to_file_claims', models.DateTimeField(blank=True, help_text='The last date for filing claims.', null=True)),
                ('date_last_to_file_govt', models.DateTimeField(blank=True, help_text='The last date for the government to file claims.', null=True)),
                ('date_debtor_dismissed', models.DateTimeField(blank=True, help_text='The date the debtor was dismissed.', null=True)),
                ('chapter', models.CharField(blank=True, help_text='The chapter the bankruptcy is currently filed under.', max_length=10)),
                ('trustee_str', models.TextField(blank=True, help_text='The name of the trustee handling the case.')),
                ('docket', models.OneToOneField(help_text='The docket that the bankruptcy info is associated with.', on_delete=django.db.models.deletion.CASCADE, related_name='bankruptcy_information', to='search.docket')),
            ],
            options={
                'verbose_name_plural': 'Bankruptcy Information',
            },
        ),
        migrations.AddIndex(
            model_name='recapdocument',
            index=models.Index(fields=['filepath_local'], name='search_recapdocument_filepath_local_7dc6b0e53ccf753_uniq'),
        ),
        migrations.AlterUniqueTogether(
            name='recapdocument',
            unique_together={('docket_entry', 'document_number', 'attachment_number')},
        ),
        migrations.AlterIndexTogether(
            name='recapdocument',
            index_together={('document_type', 'document_number', 'attachment_number')},
        ),
        migrations.AlterUniqueTogether(
            name='opinionscited',
            unique_together={('citing_opinion', 'cited_opinion')},
        ),
        migrations.AlterIndexTogether(
            name='docketentry',
            index_together={('recap_sequence_number', 'entry_number')},
        ),
        migrations.AddIndex(
            model_name='docket',
            index=models.Index(fields=['court_id', 'id'], name='search_dock_court_i_a043ae_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='docket',
            unique_together={('docket_number', 'pacer_case_id', 'court')},
        ),
        migrations.AlterIndexTogether(
            name='docket',
            index_together={('ia_upload_failure_count', 'ia_needs_upload', 'ia_date_first_change')},
        ),
        migrations.AlterUniqueTogether(
            name='citation',
            unique_together={('cluster', 'volume', 'reporter', 'page')},
        ),
        migrations.AlterIndexTogether(
            name='citation',
            index_together={('volume', 'reporter', 'page'), ('volume', 'reporter')},
        ),
    ]
