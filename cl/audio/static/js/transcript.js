// Helper function to format time (seconds to HH:MM:SS or MM:SS)
function formatTime(totalSeconds) {
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = Math.floor(totalSeconds % 60);

    const paddedSeconds = seconds.toString().padStart(2, '0');
    const paddedMinutes = minutes.toString().padStart(2, '0');

    if (hours > 0) {
        const paddedHours = hours.toString().padStart(2, '0');
        return `${paddedHours}:${paddedMinutes}:${paddedSeconds}`;
    } else {
        return `${paddedMinutes}:${paddedSeconds}`;
    }
}

$(document).ready(function() {
    // --- Transcript Handling ---
    const transcriptContainer = $('#transcript-container');
    // If transcript container doesn't exist (controlled by the 'transcript_feature' Waffle flag in the template),
    // don't run any transcript logic.
    if (!transcriptContainer.length) {
        return;
    }
    // Allow overriding the jPlayer selector via data attribute on the container, default to #jquery_jplayer_1
    const playerSelector = transcriptContainer.data('player-selector') || '#jquery_jplayer_1';
    const $player = $(playerSelector);
    const transcriptTextEl = $('#transcript-text');
    let transcriptSegments = [];

    // Create a map to track which segments are currently in view
    const segmentInViewMap = new Map();
    // Initialize IntersectionObserver to update our map on visibility changes
    const segmentObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            segmentInViewMap.set(entry.target, entry.isIntersecting);
        });
    }, {
        root: transcriptTextEl[0],
        rootMargin: '0px',
        threshold: 1.0
    });

    // State for current karaoke segment and last play position
    let currentSegmentDiv = null;
    let lastPlayPosition;

    // Simple function to scroll element into view
    function scrollToElement($element) {
        // Since we've set scroll-behavior: 'smooth' in CSS, we can use a simpler approach
        $element[0].scrollIntoView({
            block: 'center'
        });
    }

    // Find segment at a given time
    function findSegmentAtTime(time) {
        let foundSegment = null;
        // Add a small buffer time to highlight segments slightly early (in seconds)
        const LOOK_AHEAD_BUFFER = 0.3;

        transcriptTextEl.find('.transcript-segment').each(function() {
            const $segmentDiv = $(this);
            const startTime = $segmentDiv.data('start-time');
            const endTime = $segmentDiv.data('end-time');

            // Check if current time falls within this segment's time range
            if (typeof startTime === 'number' && typeof endTime === 'number' &&
                time + LOOK_AHEAD_BUFFER >= startTime && time < endTime) {
                foundSegment = $segmentDiv;
                return false; // Exit .each() loop once found
            }
        });

        return foundSegment;
    }

    // Apply appropriate highlighting to segments
    function updateSegmentHighlighting($newSegment, $oldSegment) {
        if ($oldSegment) {
            $oldSegment.removeClass('transcript-current-segment');
        }

        if ($newSegment) {
            // Don't apply current-segment if it's also the current search match
            if (!$newSegment.hasClass('transcript-search-current-match')) {
                $newSegment.addClass('transcript-current-segment');
            }

            // Check if element is in view using our map
            const isInView = segmentInViewMap.get($newSegment[0]) || false;

            // Don't autoscroll if there's search text or element is already in view
            const hasSearchText = $('#transcript-search').val().trim().length > 0;
            if (!hasSearchText && !isInView) {
                scrollToElement($newSegment);
            }
        }
    }

    try {
        // Retrieve data from the script tag generated by json_script
        const transcriptDataElement = document.getElementById('transcript-segment-data');
        if (transcriptDataElement) {
            transcriptSegments = JSON.parse(transcriptDataElement.textContent);
        } else {
            console.error("Transcript data element not found.");
            if (transcriptTextEl.length) transcriptTextEl.text("Transcript data not found.");
        }
    } catch (e) {
        console.error("Error parsing transcript JSON:", e);
        if (transcriptTextEl.length) transcriptTextEl.text("Error loading transcript data."); // Update message
    }

    function initTranscriptRendering(transcriptContainer, transcriptTextEl, transcriptSegments, segmentObserver) {
        if (transcriptSegments && transcriptSegments.length > 0) {
            transcriptTextEl.empty();
            transcriptSegments.forEach(segmentData => {
                // Ensure segment has text, start, and end times
                if (segmentData && typeof segmentData.text === 'string' && typeof segmentData.start === 'number' && typeof segmentData.end === 'number') {
                    const segmentDiv = $('<div></div>'); // Use div as container
                    segmentDiv.addClass('transcript-segment'); // Add class for styling/selection
                    segmentDiv.attr('data-start-time', segmentData.start);
                    segmentDiv.attr('data-end-time', segmentData.end);
                    segmentDiv.attr('tabindex', 0); // Make segments focusable for accessibility
                    segmentDiv.attr('role', 'button'); // Role for interaction
                    segmentDiv.attr('aria-label', `Transcript segment starting at ${formatTime(segmentData.start)}: ${segmentData.text}`);

                    // Create timestamp span
                    const timestampSpan = $('<span></span>');
                    timestampSpan.addClass('transcript-timestamp');
                    timestampSpan.text(formatTime(segmentData.start));

                    // Create text span
                    const textSpan = $('<span></span>');
                    textSpan.addClass('transcript-segment-text');
                    textSpan.text(segmentData.text);

                    // Append spans to the div
                    segmentDiv.append(timestampSpan);
                    segmentDiv.append(textSpan);

                    transcriptTextEl.append(segmentDiv); // Append the container div
                } else {
                    console.warn("Skipping invalid segment data:", segmentData);
                }
            });
            transcriptContainer.on('click', '.transcript-segment', function() {
                const startTime = $(this).data('start-time');
                // Check if startTime is a valid number
                if (typeof startTime === 'number' && !isNaN(startTime)) {
                    // Pause is required before seeking to ensure the player jumps to the correct time.
                    $player.jPlayer("pause");
                    $player.jPlayer("play", startTime);
                } else {
                    console.warn("Invalid start time clicked:", startTime);
                }
            });
            transcriptContainer.on('keydown', '.transcript-segment', function(e) {
                if (e.key === 'Enter' || e.keyCode === 13) {
                    $(this).trigger('click');
                }
            });
            transcriptTextEl.find('.transcript-segment').each(function() {
                segmentObserver.observe(this);
            });
        } else {
            $('#transcript-search').prop('disabled', true).attr('placeholder', 'Transcript unavailable');
        }
    }

    function initKaraokeHighlighting($player, findSegmentAtTime, updateSegmentHighlighting) {
        $player.bind($.jPlayer.event.timeupdate, function(event) {
            const currentTime = event.jPlayer.status.currentTime;
            const foundSegmentDiv = findSegmentAtTime(currentTime);

            // Update highlighting if the segment changed
            if (foundSegmentDiv && (!currentSegmentDiv || foundSegmentDiv[0] !== currentSegmentDiv[0])) {
                // Check if it's the first segment and playback just started
                const isFirstSegment = foundSegmentDiv.is(':first-child');
                const isPlaybackJustStarted = typeof lastPlayPosition === 'undefined' || lastPlayPosition < 3;

                // Don't auto-scroll at beginning of playback
                updateSegmentHighlighting(foundSegmentDiv, currentSegmentDiv);

                currentSegmentDiv = foundSegmentDiv;

                // Store current playback position for next update
                lastPlayPosition = currentTime;
            } else if (!foundSegmentDiv && currentSegmentDiv) {
                // Remove highlight if current time is not in any segment
                currentSegmentDiv.removeClass('transcript-current-segment');
                currentSegmentDiv = null;
            }
        });
    }

    function initTranscriptSearch(transcriptTextEl, segmentObserver, scrollToElement, updateSegmentHighlighting) {
        const $searchInput = $('#transcript-search');
        const $searchCount = $('#search-count');
        const $searchPrev = $('#search-prev');
        const $searchNext = $('#search-next');
        let searchMatches = [];
        let currentMatchIndex = -1;

        function updateSearch() {
            const searchTerm = $searchInput.val().toLowerCase().trim();
            const $segments = transcriptTextEl.find('.transcript-segment'); // Target segment divs

            // Clear previous search highlights and state
            $segments.removeClass('transcript-search-match transcript-search-current-match');
            searchMatches = [];
            currentMatchIndex = -1;
            $searchCount.text('');
            $searchPrev.prop('disabled', true);
            $searchNext.prop('disabled', true);

            if (searchTerm.length >= 2) { // Only search if term is long enough
                $segments.each(function(index) {
                    const $segmentDiv = $(this);
                    // IMPORTANT: Search only within the text span, not the timestamp
                    const segmentText = $segmentDiv.find('.transcript-segment-text').text().toLowerCase();
                    if (segmentText.includes(searchTerm)) {
                        $segmentDiv.addClass('transcript-search-match');
                        searchMatches.push($segmentDiv); // Store the jQuery object
                    }
                });

                if (searchMatches.length > 0) {
                    currentMatchIndex = 0; // Start at the first match
                    highlightCurrentMatch();
                    updateNavButtons();
                    $searchCount.text(`${searchMatches.length} found`);
                } else {
                    $searchCount.text('0 found');
                }
            } else {
                // When search is cleared or too short, reapply highlighting to current segment
                if (currentSegmentDiv) {
                    currentSegmentDiv.addClass('transcript-current-segment');
                    // If not in view, scroll to it
                    const isInView = segmentInViewMap.get(currentSegmentDiv[0]) || false;

                    if (!isInView) {
                        scrollToElement(currentSegmentDiv);
                    }
                }
            }
        }

        function highlightCurrentMatch() {
            $('.transcript-search-current-match').removeClass('transcript-search-current-match');
            if (currentMatchIndex >= 0 && currentMatchIndex < searchMatches.length) {
                const $currentMatch = searchMatches[currentMatchIndex];
                $currentMatch.addClass('transcript-search-current-match');
                // Remove karaoke highlight only from this specific element
                $currentMatch.removeClass('transcript-current-segment');

                // Scroll the current match into view
                scrollToElement($currentMatch);
            }
        }

        function updateNavButtons() {
            $searchPrev.prop('disabled', currentMatchIndex <= 0);
            $searchNext.prop('disabled', currentMatchIndex >= searchMatches.length - 1);
        }

        // Debounce the search input to avoid jank on long transcripts
        let searchDebounceTimer;
        $searchInput.on('input', function() {
            clearTimeout(searchDebounceTimer);
            searchDebounceTimer = setTimeout(updateSearch, 200);
        });

        $searchPrev.on('click', function() {
            if (currentMatchIndex > 0) {
                currentMatchIndex--;
                highlightCurrentMatch();
                updateNavButtons();
            }
        });
        $searchNext.on('click', function() {
            if (currentMatchIndex < searchMatches.length - 1) {
                currentMatchIndex++;
                highlightCurrentMatch();
                updateNavButtons();
            }
        });
    }

    initTranscriptRendering(transcriptContainer, transcriptTextEl, transcriptSegments, segmentObserver);
    initKaraokeHighlighting($player, findSegmentAtTime, updateSegmentHighlighting);
    initTranscriptSearch(transcriptTextEl, segmentObserver, scrollToElement, updateSegmentHighlighting);
});