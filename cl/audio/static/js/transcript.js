// Helper function to format time (seconds to HH:MM:SS or MM:SS)
function formatTime(totalSeconds) {
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = Math.floor(totalSeconds % 60);

    const paddedSeconds = seconds.toString().padStart(2, '0');
    const paddedMinutes = minutes.toString().padStart(2, '0');

    if (hours > 0) {
        const paddedHours = hours.toString().padStart(2, '0');
        return `${paddedHours}:${paddedMinutes}:${paddedSeconds}`;
    } else {
        return `${paddedMinutes}:${paddedSeconds}`;
    }
}

$(document).ready(function() {
    // --- Transcript Handling ---
    const transcriptContainer = $('#transcript-container');
    // If transcript container doesn't exist (controlled by the 'transcript_feature' Waffle flag in the template),
    // don't run any transcript logic.
    if (!transcriptContainer.length) {
        return;
    }
    // Allow overriding the jPlayer selector via data attribute on the container, default to #jquery_jplayer_1
    const playerSelector = transcriptContainer.data('player-selector') || '#jquery_jplayer_1';
    const $player = $(playerSelector);
    const transcriptTextEl = $('#transcript-text');
    let transcriptSegments = [];

    // Create a map to track which segments are currently in view
    const segmentInViewMap = new Map();
    // Initialize IntersectionObserver to update our map on visibility changes
    const segmentObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            segmentInViewMap.set(entry.target, entry.isIntersecting);
        });
    }, {
        root: transcriptTextEl[0],
        rootMargin: '0px',
        threshold: 1.0
    });

    // State for current karaoke segment and last play position
    let currentSegmentDiv = null;
    let lastPlayPosition;

    // Simple function to scroll element into view
    function scrollToElement($element) {
        // Since we've set scroll-behavior: 'smooth' in CSS, we can use a simpler approach
        $element[0].scrollIntoView({
            block: 'center'
        });
    }

    // Find segment at a given time
    function findSegmentAtTime(time) {
        let foundSegment = null;
        // Add a small buffer time to highlight segments slightly early (in seconds)
        const LOOK_AHEAD_BUFFER = 0.3;

        transcriptTextEl.find('.transcript-segment').each(function() {
            const $segmentDiv = $(this);
            const startTime = $segmentDiv.data('start-time');
            const endTime = $segmentDiv.data('end-time');

            // Check if current time falls within this segment's time range
            if (typeof startTime === 'number' && typeof endTime === 'number' &&
                time + LOOK_AHEAD_BUFFER >= startTime && time < endTime) {
                foundSegment = $segmentDiv;
                return false; // Exit .each() loop once found
            }
        });

        return foundSegment;
    }

    // Apply appropriate highlighting to segments
    function updateSegmentHighlighting($newSegment, $oldSegment) {
        if ($oldSegment) {
            $oldSegment.removeClass('transcript-current-segment');
        }

        if ($newSegment) {
            $newSegment.addClass('transcript-current-segment');

            // Check if element is in view using our map
            const isInView = segmentInViewMap.get($newSegment[0]) || false;

            // Don't autoscroll if element is already in view
            if (!isInView) {
                scrollToElement($newSegment);
            }
        }
    }

    try {
        // Retrieve data from the script tag generated by json_script
        const transcriptDataElement = document.getElementById('transcript-segment-data');
        if (transcriptDataElement) {
            transcriptSegments = JSON.parse(transcriptDataElement.textContent);
        } else {
            console.error("Transcript data element not found.");
            if (transcriptTextEl.length) transcriptTextEl.text("Transcript data not found.");
        }
    } catch (e) {
        console.error("Error parsing transcript JSON:", e);
        if (transcriptTextEl.length) transcriptTextEl.text("Error loading transcript data."); // Update message
    }

    function initTranscriptRendering(transcriptContainer, transcriptTextEl, transcriptSegments, segmentObserver) {
        if (transcriptSegments && transcriptSegments.length > 0) {
            transcriptTextEl.empty();
            transcriptSegments.forEach(segmentData => {
                // Ensure segment has text, start, and end times
                if (segmentData && typeof segmentData.text === 'string' && typeof segmentData.start === 'number' && typeof segmentData.end === 'number') {
                    const segmentDiv = $('<div></div>'); // Use div as container
                    segmentDiv.addClass('transcript-segment'); // Add class for styling/selection
                    segmentDiv.attr('data-start-time', segmentData.start);
                    segmentDiv.attr('data-end-time', segmentData.end);
                    segmentDiv.attr('tabindex', 0); // Make segments focusable for accessibility
                    segmentDiv.attr('role', 'button'); // Role for interaction
                    segmentDiv.attr('aria-label', `Transcript segment starting at ${formatTime(segmentData.start)}: ${segmentData.text}`);

                    // Create timestamp span
                    const timestampSpan = $('<span></span>');
                    timestampSpan.addClass('transcript-timestamp');
                    timestampSpan.text(formatTime(segmentData.start));

                    // Create text span
                    const textSpan = $('<span></span>');
                    textSpan.addClass('transcript-segment-text');
                    textSpan.text(segmentData.text);

                    // Append spans to the div
                    segmentDiv.append(timestampSpan);
                    segmentDiv.append(textSpan);

                    transcriptTextEl.append(segmentDiv); // Append the container div
                } else {
                    console.warn("Skipping invalid segment data:", segmentData);
                }
            });
            transcriptContainer.on('click', '.transcript-segment', function() {
                const startTime = $(this).data('start-time');
                // Check if startTime is a valid number
                if (typeof startTime === 'number' && !isNaN(startTime)) {
                    // Pause is required before seeking to ensure the player jumps to the correct time.
                    $player.jPlayer("pause");
                    $player.jPlayer("play", startTime);
                } else {
                    console.warn("Invalid start time clicked:", startTime);
                }
            });
            transcriptContainer.on('keydown', '.transcript-segment', function(e) {
                if (e.key === 'Enter' || e.keyCode === 13) {
                    $(this).trigger('click');
                }
            });
            transcriptTextEl.find('.transcript-segment').each(function() {
                segmentObserver.observe(this);
            });
        }
    }

    function initKaraokeHighlighting($player, findSegmentAtTime, updateSegmentHighlighting) {
        $player.bind($.jPlayer.event.timeupdate, function(event) {
            const currentTime = event.jPlayer.status.currentTime;
            const foundSegmentDiv = findSegmentAtTime(currentTime);

            // Update highlighting if the segment changed
            if (foundSegmentDiv && (!currentSegmentDiv || foundSegmentDiv[0] !== currentSegmentDiv[0])) {
                // Check if it's the first segment and playback just started
                const isFirstSegment = foundSegmentDiv.is(':first-child');
                const isPlaybackJustStarted = typeof lastPlayPosition === 'undefined' || lastPlayPosition < 3;

                // Don't auto-scroll at beginning of playback
                updateSegmentHighlighting(foundSegmentDiv, currentSegmentDiv);

                currentSegmentDiv = foundSegmentDiv;

                // Store current playback position for next update
                lastPlayPosition = currentTime;
            } else if (!foundSegmentDiv && currentSegmentDiv) {
                // Remove highlight if current time is not in any segment
                currentSegmentDiv.removeClass('transcript-current-segment');
                currentSegmentDiv = null;
            }
        });
    }



    initTranscriptRendering(transcriptContainer, transcriptTextEl, transcriptSegments, segmentObserver);
    initKaraokeHighlighting($player, findSegmentAtTime, updateSegmentHighlighting);
});